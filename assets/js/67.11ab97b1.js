(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{390:function(t,s,a){"use strict";a.r(s);var e=a(4),r=Object(e.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"vue轮子"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue轮子"}},[t._v("#")]),t._v(" VUE轮子")]),t._v(" "),s("h2",{attrs:{id:"tabs组件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tabs组件"}},[t._v("#")]),t._v(" tabs组件")]),t._v(" "),s("p",[t._v("tabs组件核心在于组件之间的通讯，我使用的是eventBus来做组件通讯")]),t._v(" "),s("ul",[s("li",[t._v("bus定义到全局(在eventBus中，bus本身就是vue对象本身)")]),t._v(" "),s("li",[t._v("然后在组件中，可以使用 $emit, $on, $off 分别来分发、监听、取消监听事件")])]),t._v(" "),s("h2",{attrs:{id:"popover组件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#popover组件"}},[t._v("#")]),t._v(" popover组件")]),t._v(" "),s("p",[t._v("popover组件常见的写法是气泡框用v-show来隐藏在按钮附近，我参考了其他热门的组件库使用了v-if来写并且气泡框不依赖按钮，而是在body.append接入气泡元素，这里的难点在于气泡如何获取精准的按钮位置并且显示出来。")]),t._v(" "),s("h2",{attrs:{id:"toast组件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#toast组件"}},[t._v("#")]),t._v(" toast组件")]),t._v(" "),s("p",[t._v("与popover组件同理，但我用了vue的plugin插件来实现$toast这个方法。")])])}),[],!1,null,null,null);s.default=r.exports}}]);