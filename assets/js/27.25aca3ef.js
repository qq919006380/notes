(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{350:function(t,a,r){"use strict";r.r(a);var s=r(4),e=Object(s.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"虚拟dom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom"}},[t._v("#")]),t._v(" 虚拟DOM")]),t._v(" "),a("h3",{attrs:{id:"主要用处"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#主要用处"}},[t._v("#")]),t._v(" 主要用处")]),t._v(" "),a("p",[t._v("虚拟DOM主要用于映射真实DOM上，用于减少重复的大量的DOM渲染。将原来频繁的dom操作合并起来。")]),t._v(" "),a("h3",{attrs:{id:"原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[t._v("#")]),t._v(" 原理")]),t._v(" "),a("p",[t._v("通过javascript对象表示出一个虚拟DOM用来映射真实DOM，视图的结构确实是整个全新渲染了，但是最后操作DOM的时候确实只变更有不同的地方。")]),t._v(" "),a("h3",{attrs:{id:"virtual-dom-算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#virtual-dom-算法"}},[t._v("#")]),t._v(" Virtual DOM 算法")]),t._v(" "),a("p",[t._v("1 用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中\n2 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异（diff算法，diff也是虚拟dom的核心）\n3 把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了")]),t._v(" "),a("p",[t._v("Virtual DOM与DocumentFragment\nVirtualDOM的目的是不仅允许对稍后注入DOM的系统进行大规模编辑，而且允许在不存在DOM的环境中进行任何编辑。这是DocumentFragments和VirtualDOM的实际应用之间的最大区别。")])])}),[],!1,null,null,null);a.default=e.exports}}]);